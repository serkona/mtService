# Сервер
## Запуск сервиса

Запустить в терминале скрипт `start.bash`

## Как запускается сервер

Скрипт `start.bash` выполняет команду `docker-compose up -d`,
которая поднимает базу данных PostgreSQL в фоновом режиме и 
создаёт таблицу с помощью `initDb.sql`.

После этого скрипт запускает само ***Spring Boot*** приложение с помощью ***Maven***, которое, предварительно заполнив данными базу, работает локально на порту `8080`.


# Клиент

## Как реализован

Клиент реализован фоновым процессом (с помощью аннотации `@Scheduled`), выполняющимся через определённый интервал времени, который можно изменить в `ClientService`, так же как и количество рабочих потоков.

Отправка запросов реализована с помощью `Spring Web Client`, который поддерживает многопоточность.



# Архитектура

## Структура

### 1. Контроллеры

- Контроллер `MtController` с двумя методами, которые используют методы соответствующего сервиса `BalanceServiceImpl`.

Методы:
- ***GET*** `getBalance`(Код ответа: 200 или 404) 
- ***PUT*** `changeBalance` (Код ответа: 200 или 201).


- Также там расположен `ExceptionHandler` для того, чтобы перехватывать ошибки, связанные с многопоточной работой приложения.
        

### 2. Сервисы

- В приложении один сервис `BalanceServiceImpl`, реализующий интерфейс `BalanceService`, данный в документации сервиса.

### 3. Репозитории
- Стандартный JPA репозиторий для Entity `Account`

### 4. Entity
- Компонент `Account` для хранения счётов пользователей.
- Содержит два поля: `id (long)` и `balance (long)`.

## Cache

Поддержка кэша реализована также с помощью `Spring` и соответствующих аннотаций `@EnableCaching`, `@CacheConfig` и `@CachePut`.

## Асинхронность

Поддержка асинхронной обработки запросов реализована также с помощью `Spring` и соответствующих аннотаций `@Async` (`@EnableAsync`).


## Тесты

Также были реализованы интеграционные тесты (с помощью `@SpringBootTest`) контроллеров. Модульных тестов я решил не писать, т.к. внутрення логика совсем несложная, и интеграционные тесты её так же хорошо покрывают. 


# Примечания

## REST
Я использовал `REST` для общения между клиентом и сервером, т.к. он широко распространён и с ним мне приходилось работать чаще всего.


## Docker

Я решил использовать `Docker`, чтобы не было необходимости устанавливать ***сервер БД*** локально для проверки работы приложения. 
Однако само приложение помещать в контейнер я не стал, т.к. для его проверки в этом нет необходимости, а для упрощения деплоя это делать не имеет смысл, ведь это тестовое задание.

## Работа с данными

В процессе выбора способа заполнения базы, я решил всё-таки остановиться на использовании репозиториев, хотя в начале для этого использовался `SQL` скрипт (можно увидеть в более ранних коммитах).
Заполнение прямым запросом наверное было бы более быстрым, но т.к. вся основная логика и так реализована с помощью ORM, особой оптимизации это бы не дало.

Возможно для работы с базой было бы более эффективно работать с базой запросами напрямую, ведь `ORM` способно сгенерировать не самые эффективные запросы, что особенно важно, ведь приложение должно работать под высокой нагрузкой.

Но т.к. бизнес-логика сервиса не предусматривает сложных запросов, которые вручную можно было бы сделать эффективнее, я решил всё-таки остановиться на `ORM`.

## Изменение баланса

В условиях задачи указано, что сервис должен изменять баланс пользователя по запросу, но ничего не сказано о добавлении нового пользователя.

Поэтому я решил попробовать трактовать это самостоятельно: т.к. для изменения данных на сервере по `REST` нужно использовать `PUT`, который (по документации) должен добавлять новую запись, если она не была найдена для обновления.

Поэтому я реализовал логику, при которой метод изменения баланса добавляет нового пользователя, если он не был найден для обновления его баланса.

Однако это может создавать сложности при одновременном доступе к источнику из нескольких потоков.

